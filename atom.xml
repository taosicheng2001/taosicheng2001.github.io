<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ソラの小屋</title>
  
  
  <link href="https://taosicheng2001.github.io/atom.xml" rel="self"/>
  
  <link href="https://taosicheng2001.github.io/"/>
  <updated>2024-07-25T08:42:43.713Z</updated>
  <id>https://taosicheng2001.github.io/</id>
  
  <author>
    <name>Sora</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NOC: Researches on Cache Coherency NOC Router and Flow Control</title>
    <link href="https://taosicheng2001.github.io/2024/07/16/NOC-Researches-on-Cache-Coherency-NOC-Router-and-Flow-Control/"/>
    <id>https://taosicheng2001.github.io/2024/07/16/NOC-Researches-on-Cache-Coherency-NOC-Router-and-Flow-Control/</id>
    <published>2024-07-16T02:54:52.000Z</published>
    <updated>2024-07-25T08:42:43.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="further-reading"><a class="markdownIt-Anchor" href="#further-reading"></a> Further Reading</h1><p>Duato 自适应算法无死锁[167, 204, 205]<br />基于切片的虫孔交换[170]</p><h1 id="chapter-3"><a class="markdownIt-Anchor" href="#chapter-3"></a> Chapter 3</h1><p>多程序运行在同一众核平台上，引入了负载整合工作模式（多个核心划分为多个区域，每个程序使用其中一个区域）</p><p>多个应用程序的隔离+有效共享片上资源</p><p>提供足够的适应性解决拥塞，不利用冗余的网络状态信息，动态隔离多个程序</p><p>自适应路由=路由函数+选择策略</p><p>应用程序内部的干扰+应用程序之间的干扰 =&gt; 当前位置和目标节点确定的区域外的所有路由都不应该被进入网络状态信息统计</p><p>拥塞信息传播网络 =&gt; 西侧和本地的东输入端口状态传递给东侧，其他方向和维度同理。</p><p>指标计算SMC 维度预选择DP 路由计算RC 虚通道分配VA 交叉开关分配SA 交叉开关传输ST 链路传输LT<br />SMC 考察congestion_X和congestion_Y的相对大小，以确定cur节点到pos节点的out_dim选择</p><h1 id="chapter-4"><a class="markdownIt-Anchor" href="#chapter-4"></a> Chapter 4</h1><p>路由算法要求无死锁 网络层死锁 or 协议层死锁</p><p>128位flit宽度下 一致性控制消息只需要1flit编码即可(且占比高78.7%) Cache行数据消息需要5flit编码</p><p>片上连线资源丰富，但缓存资源紧缺</p><p>WPF(whole packet forwarding): 如果一条非空虚通道有足够的空闲缓存来接收整个报文，则允许非空虚通道被重新分配</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;further-reading&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#further-reading&quot;&gt;&lt;/a&gt; Further Reading&lt;/h1&gt;
&lt;p&gt;Duato 自适应算法无死锁[167, 204, 205]&lt;br </summary>
      
    
    
    
    <category term="Computer Architecture" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/"/>
    
    <category term="Network On Chip" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/Network-On-Chip/"/>
    
    
    <category term="Paper Reading" scheme="https://taosicheng2001.github.io/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://taosicheng2001.github.io/2024/05/05/hello-world/"/>
    <id>https://taosicheng2001.github.io/2024/05/05/hello-world/</id>
    <published>2024-05-05T15:00:58.487Z</published>
    <updated>2024-05-05T15:00:58.487Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mn>3</mn><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msqrt><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sqrt{3x-1}+(1+x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.17444499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">3</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RISCV-BOOM(3)</title>
    <link href="https://taosicheng2001.github.io/2024/04/11/RISCV-BOOM-3/"/>
    <id>https://taosicheng2001.github.io/2024/04/11/RISCV-BOOM-3/</id>
    <published>2024-04-11T11:59:01.000Z</published>
    <updated>2024-05-05T15:00:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riscv-boom-icache"><a class="markdownIt-Anchor" href="#riscv-boom-icache"></a> RISCV-BOOM ICACHE</h1><p>在RISCV-BOOM(2)中，我们对BOOM的前端代码(<code>frontend.scala</code>)进行了简要分析，发现除了F3内针对<code>fetch_bundle</code>的处理外，其余部分都在作为顶层模组，完成对各个子模组的连接。所以要真正理解前端的各种实现，我们还需要对各个子模组进行分析和理解。本文针对ICache进行分析，其代码为<code>icache.scala</code>。</p><h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2><h3 id="icache"><a class="markdownIt-Anchor" href="#icache"></a> <code>ICache</code></h3><p>包装了<code>ICache Module</code>实例化的类，通过调整传入参数<code>icacheParams</code>可进行快速配置。在实例化<code>ICacheModule</code>的同时，也设置了<code>masterNode</code>，这是片上互联的一种节点。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ICache module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param icacheParams parameters for the icache</span></span><br><span class="line"><span class="comment"> * @param hartId the id of the hardware thread in the cache</span></span><br><span class="line"><span class="comment"> * @param enableBlackBox use a blackbox icache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICache</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  val icacheParams: <span class="type">ICacheParams</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  val staticIdForMetadataUseOnly: <span class="type">Int</span></span>)(<span class="params">implicit p: <span class="type">Parameters</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">LazyModule</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> module = <span class="keyword">new</span> <span class="type">ICacheModule</span>(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">val</span> masterNode = <span class="type">TLClientNode</span>(<span class="type">Seq</span>(<span class="type">TLMasterPortParameters</span>.v1(<span class="type">Seq</span>(<span class="type">TLMasterParameters</span>.v1(</span><br><span class="line">    sourceId = <span class="type">IdRange</span>(<span class="number">0</span>, <span class="number">1</span> + icacheParams.prefetch.toInt), <span class="comment">// 0=refill, 1=hint</span></span><br><span class="line">    name = <span class="string">s&quot;Core <span class="subst">$&#123;staticIdForMetadataUseOnly&#125;</span> ICache&quot;</span>)))))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> size = icacheParams.nSets * icacheParams.nWays * icacheParams.blockBytes</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> wordBytes = icacheParams.fetchBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="icacheresp"><a class="markdownIt-Anchor" href="#icacheresp"></a> <code>ICacheResp</code></h3><p>离开ICache的IO信号(ICache返回到Frontend的信号)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICacheResp</span>(<span class="params">val outer: <span class="type">ICache</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> data = <span class="type">UInt</span>((outer.icacheParams.fetchBytes*<span class="number">8</span>).<span class="type">W</span>)</span><br><span class="line">  <span class="keyword">val</span> replay = <span class="type">Bool</span>()</span><br><span class="line">  <span class="keyword">val</span> ae = <span class="type">Bool</span>() <span class="comment">// Access Exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="icache-bundle"><a class="markdownIt-Anchor" href="#icache-bundle"></a> <code>ICache Bundle</code></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICacheBundle</span>(<span class="params">val outer: <span class="type">ICache</span></span>) <span class="keyword">extends</span> <span class="title">BoomBundle</span>(<span class="params"></span>)(<span class="params">outer.p</span>)</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">HasBoomFrontendParameters</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> req = <span class="type">Flipped</span>(<span class="type">Decoupled</span>(<span class="keyword">new</span> <span class="type">ICacheReq</span>)) <span class="comment">// Decoupled是生产者——消费者数据传输模型接口，具有valid, bits. ready这三个信号。 这个接口是站在数据传输者的角度定义数据传输方向的</span></span><br><span class="line">  <span class="comment">// Flipped将该数据传输方向翻转</span></span><br><span class="line">  <span class="comment">// 两者结合后，该数据传输方向为外到内</span></span><br><span class="line">  <span class="keyword">val</span> s1_paddr = <span class="type">Input</span>(<span class="type">UInt</span>(paddrBits.<span class="type">W</span>)) <span class="comment">// delayed one cycle w.r.t. req</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> s1_kill = <span class="type">Input</span>(<span class="type">Bool</span>()) <span class="comment">// delayed one cycle w.r.t. req</span></span><br><span class="line">  <span class="keyword">val</span> s2_kill = <span class="type">Input</span>(<span class="type">Bool</span>()) <span class="comment">// delayed two cycles; prevents I$ miss emission</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> resp = <span class="type">Valid</span>(<span class="keyword">new</span> <span class="type">ICacheResp</span>(outer)) <span class="comment">// Valid会生成一个新Bundle,带有valid和bits这两个信号</span></span><br><span class="line">  <span class="keyword">val</span> invalidate = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> perf = <span class="type">Output</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> acquire = <span class="type">Bool</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="icachemodule"><a class="markdownIt-Anchor" href="#icachemodule"></a> <code>ICacheModule</code></h3><p>实际实现功能的类，定义了ICache内部信号的生成和传输。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICacheModule</span>(<span class="params">outer: <span class="type">ICache</span></span>) <span class="keyword">extends</span> <span class="title">LazyModuleImp</span>(<span class="params">outer</span>)</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">HasBoomFrontendParameters</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> enableICacheDelay = tileParams.core.asInstanceOf[<span class="type">BoomCoreParams</span>].enableICacheDelay</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">ICacheBundle</span>(outer))</span><br><span class="line">  <span class="keyword">val</span> (tl_out, edge_out) = outer.masterNode.out(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  require(isPow2(nSets) &amp;&amp; isPow2(nWays))</span><br><span class="line">  require(usingVM)</span><br><span class="line">  require(pgIdxBits &gt;= untagBits)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// How many bits do we intend to fetch at most every cycle?</span></span><br><span class="line">  <span class="keyword">val</span> wordBits = outer.icacheParams.fetchBytes*<span class="number">8</span>  <span class="comment">// fetchBytes = 8</span></span><br><span class="line">  <span class="comment">// Each of these cases require some special-case handling.</span></span><br><span class="line">  require (tl_out.d.bits.data.getWidth == wordBits || (<span class="number">2</span>*tl_out.d.bits.data.getWidth == wordBits &amp;&amp; nBanks == <span class="number">2</span>))</span><br><span class="line">  <span class="comment">// If TL refill is half the wordBits size and we have two banks, then the</span></span><br><span class="line">  <span class="comment">// refill writes to only one bank per cycle (instead of across two banks every</span></span><br><span class="line">  <span class="comment">// cycle).</span></span><br><span class="line">  <span class="keyword">val</span> refillsToOneBank = (<span class="number">2</span>*tl_out.d.bits.data.getWidth == wordBits)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// nWays = 4; nSets = 64</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> s0_valid = io.req.fire <span class="comment">// fire信号是valid &amp; ready, 来自frontend的fire </span></span><br><span class="line">  <span class="keyword">val</span> s0_vaddr = io.req.bits.addr <span class="comment">// 传入VA</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> s1_valid = <span class="type">RegNext</span>(s0_valid)</span><br><span class="line">  <span class="keyword">val</span> s1_tag_hit = <span class="type">Wire</span>(<span class="type">Vec</span>(nWays, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> s1_hit = s1_tag_hit.reduce(_||_)</span><br><span class="line">  <span class="keyword">val</span> s2_valid = <span class="type">RegNext</span>(s1_valid &amp;&amp; !io.s1_kill)</span><br><span class="line">  <span class="keyword">val</span> s2_hit = <span class="type">RegNext</span>(s1_hit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> invalidated = <span class="type">Reg</span>(<span class="type">Bool</span>())</span><br><span class="line">  <span class="keyword">val</span> refill_valid = <span class="type">RegInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line">  <span class="keyword">val</span> refill_fire = tl_out.a.fire</span><br><span class="line">  <span class="keyword">val</span> s2_miss = s2_valid &amp;&amp; !s2_hit &amp;&amp; !<span class="type">RegNext</span>(refill_valid)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Refill Sign</span></span><br><span class="line">  <span class="keyword">val</span> refill_paddr = <span class="type">RegEnable</span>(io.s1_paddr, s1_valid &amp;&amp; !(refill_valid || s2_miss)) <span class="comment">// RegEnable(nextVal, ena)</span></span><br><span class="line">  <span class="comment">// untagBits = blockOffBits + idxBits</span></span><br><span class="line">  <span class="keyword">val</span> refill_tag = refill_paddr(tagBits+untagBits<span class="number">-1</span>,untagBits)</span><br><span class="line">  <span class="keyword">val</span> refill_idx = refill_paddr(untagBits<span class="number">-1</span>,blockOffBits)</span><br><span class="line">  <span class="keyword">val</span> refill_one_beat = tl_out.d.fire &amp;&amp; edge_out.hasData(tl_out.d.bits) <span class="comment">// 通过TileLink节点连接下层存储</span></span><br><span class="line"></span><br><span class="line">  io.req.ready := !refill_one_beat <span class="comment">// ready的前提是没有refill_one_beat</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> (_, _, d_done, refill_cnt) = edge_out.count(tl_out.d)</span><br><span class="line">  <span class="keyword">val</span> refill_done = refill_one_beat &amp;&amp; d_done</span><br><span class="line">  tl_out.d.ready := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">  require (edge_out.manager.minLatency &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> repl_way = <span class="keyword">if</span> (isDM) <span class="number">0.</span><span class="type">U</span> <span class="keyword">else</span> <span class="type">LFSR</span>(<span class="number">16</span>, refill_fire)(log2Ceil(nWays)<span class="number">-1</span>,<span class="number">0</span>) <span class="comment">// Replace_Way;  LFSR(width, increment_Ena) 产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        way0  ...   way15</span></span><br><span class="line"><span class="comment">    |---------|---------|  set0 </span></span><br><span class="line"><span class="comment">    |---------|---------|  set1</span></span><br><span class="line"><span class="comment">    |---------|---------|  ...</span></span><br><span class="line"><span class="comment">    |---------|---------|  set63</span></span><br><span class="line"><span class="comment">    |-------------------|  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">val</span> tag_array = <span class="type">SyncReadMem</span>(nSets, <span class="type">Vec</span>(nWays, <span class="type">UInt</span>(tagBits.<span class="type">W</span>))) <span class="comment">// 存储Tag的阵列,SyncReadMem(sizeNumber, dataType), Vec(sizeNumber, dataType)</span></span><br><span class="line">  <span class="keyword">val</span> tag_rdata = tag_array.read(s0_vaddr(untagBits<span class="number">-1</span>, blockOffBits), !refill_done &amp;&amp; s0_valid) <span class="comment">// 用index索引set去读Tag_array,得到nWay个Tag； 函数调用read(index, ena)</span></span><br><span class="line">  when (refill_done) &#123;</span><br><span class="line">    tag_array.write(refill_idx, <span class="type">VecInit</span>(<span class="type">Seq</span>.fill(nWays)(refill_tag)), <span class="type">Seq</span>.tabulate(nWays)(repl_way === _.<span class="type">U</span>)) </span><br><span class="line">    <span class="comment">// 函数调用 write(index, data, mask) </span></span><br><span class="line">    <span class="comment">// 函数调用 Seq.fill(number)(genElement) </span></span><br><span class="line">    <span class="comment">// 函数调用 Seq.tabulate(number)(genFunc)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> vb_array = <span class="type">RegInit</span>(<span class="number">0.</span><span class="type">U</span>((nSets*nWays).<span class="type">W</span>)) <span class="comment">// valid_bit_array</span></span><br><span class="line">  when (refill_one_beat) &#123;</span><br><span class="line">    vb_array := vb_array.bitSet(<span class="type">Cat</span>(repl_way, refill_idx), refill_done &amp;&amp; !invalidated)</span><br><span class="line">    <span class="comment">// 函数调用 bitSet(index, bool_value)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  when (io.invalidate) &#123;</span><br><span class="line">    vb_array := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">    invalidated := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> s2_dout   = <span class="type">Wire</span>(<span class="type">Vec</span>(nWays, <span class="type">UInt</span>(wordBits.<span class="type">W</span>)))</span><br><span class="line">  <span class="keyword">val</span> s1_bankid = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算tag_hit</span></span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until nWays) &#123;</span><br><span class="line">    <span class="keyword">val</span> s1_idx = io.s1_paddr(untagBits<span class="number">-1</span>,blockOffBits) <span class="comment">// 感觉这个s1_idx没啥必要</span></span><br><span class="line">    <span class="keyword">val</span> s1_tag = io.s1_paddr(tagBits+untagBits<span class="number">-1</span>,untagBits)</span><br><span class="line">    <span class="keyword">val</span> s1_vb = vb_array(<span class="type">Cat</span>(i.<span class="type">U</span>, s1_idx))</span><br><span class="line">    <span class="keyword">val</span> tag = tag_rdata(i)</span><br><span class="line">    s1_tag_hit(i) := s1_vb &amp;&amp; tag === s1_tag</span><br><span class="line">  &#125;</span><br><span class="line">  assert(<span class="type">PopCount</span>(s1_tag_hit) &lt;= <span class="number">1.</span><span class="type">U</span> || !s1_valid) <span class="comment">// 最多只有一路命中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里还考虑了refill的周期数，利用refill_cnt把不同cnt下的值都保存</span></span><br><span class="line">  <span class="keyword">val</span> ramDepth = <span class="keyword">if</span> (refillsToOneBank &amp;&amp; nBanks == <span class="number">2</span>) &#123;</span><br><span class="line">    nSets * refillCycles / <span class="number">2</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nSets * refillCycles</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dataArrays[wayIndex][setIndex]</span></span><br><span class="line">  <span class="keyword">val</span> dataArrays = <span class="keyword">if</span> (nBanks == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Use unbanked icache for narrow accesses.</span></span><br><span class="line">    <span class="comment">// 这里的dataArray是具有nWays个元素的map，每个元素是一个SyncReadMem，深度为wordBits</span></span><br><span class="line">    (<span class="number">0</span> until nWays).map &#123; x =&gt;</span><br><span class="line">      <span class="type">DescribedSRAM</span>(</span><br><span class="line">        name = <span class="string">s&quot;dataArrayWay_<span class="subst">$&#123;x&#125;</span>&quot;</span>,</span><br><span class="line">        desc = <span class="string">&quot;ICache Data Array&quot;</span>,</span><br><span class="line">        size = ramDepth,</span><br><span class="line">        data = <span class="type">UInt</span>((wordBits).<span class="type">W</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use two banks, interleaved. 分双bank,多体交叉编址</span></span><br><span class="line">    <span class="comment">// 这里的dataArray是具有nWays+nWays个元素的map，每个元素是一个SyncReadMem，深度为wordBits/nBanks</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">0</span> until nWays).map &#123; x =&gt;</span><br><span class="line">      <span class="type">DescribedSRAM</span>(</span><br><span class="line">        name = <span class="string">s&quot;dataArrayB0Way_<span class="subst">$&#123;x&#125;</span>&quot;</span>,</span><br><span class="line">        desc = <span class="string">&quot;ICache Data Array&quot;</span>,</span><br><span class="line">        size = ramDepth,</span><br><span class="line">        data = <span class="type">UInt</span>((wordBits/nBanks).<span class="type">W</span>)</span><br><span class="line">      )&#125; ++</span><br><span class="line">    (<span class="number">0</span> until nWays).map &#123; x =&gt;</span><br><span class="line">      <span class="type">DescribedSRAM</span>(</span><br><span class="line">        name = <span class="string">s&quot;dataArrayB1Way_<span class="subst">$&#123;x&#125;</span>&quot;</span>,</span><br><span class="line">        desc = <span class="string">&quot;ICache Data Array&quot;</span>,</span><br><span class="line">        size = ramDepth,</span><br><span class="line">        data = <span class="type">UInt</span>((wordBits/nBanks).<span class="type">W</span>)</span><br><span class="line">      )&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">      MSB                                    LSB</span></span><br><span class="line"><span class="comment">       [ tagBits ][ indexBits ][ blockOffBits ] paddr，传入Icache的物理地址</span></span><br><span class="line"><span class="comment">                  [ indexBits ]                 refill_idx对应的字段</span></span><br><span class="line"><span class="comment">        [ indexBits ][  lgRC  ][ blockOffBits ] 不分Bank的dataArrays[x_Ways]的寻址模式，这里的lgRC是log2Ceil(refillCycles);</span></span><br><span class="line"><span class="comment">                  [     row    [  lgRC  ]]      不分bank下row对应的字段(截取vaddr)</span></span><br><span class="line"><span class="comment">          [ indexBits ][lgRC-1][ blockOffBits ] 分Bank的dataArraysBx[x_Ways] 里面的寻址模式;整体容量小了一半</span></span><br><span class="line"><span class="comment">                  [    b0row   [lgRC-1]]        分bank下bxrow(refillsToOneBank)对应的字段(截取vaddr)</span></span><br><span class="line"><span class="comment">                  [   b0row    [  lgRC  ]]      分bank下bxrow(!refillsToOneBank)对应的字段(截取vaddr)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nBanks == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Use unbanked icache for narrow accesses.</span></span><br><span class="line">    s1_bankid := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">    <span class="keyword">for</span> ((dataArray, i) &lt;- dataArrays.zipWithIndex) &#123;</span><br><span class="line">      <span class="comment">// 函数调用 zipWithIndex 返回列表元素和其下标 [(ele0, 0), (ele1, 1), ..., (elen, n)]</span></span><br><span class="line">      <span class="comment">// 这里返回nWays个元素，每个元素是一个SyncReadMem</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">row</span></span>(addr: <span class="type">UInt</span>) = addr(untagBits<span class="number">-1</span>, blockOffBits-log2Ceil(refillCycles))</span><br><span class="line">      <span class="keyword">val</span> s0_ren = s0_valid</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> wen = (refill_one_beat &amp;&amp; !invalidated) &amp;&amp; repl_way === i.<span class="type">U</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> mem_idx = <span class="type">Mux</span>(refill_one_beat, (refill_idx &lt;&lt; log2Ceil(refillCycles)) | refill_cnt,</span><br><span class="line">                    row(s0_vaddr))</span><br><span class="line">      <span class="comment">// refill_idx 用的是paddr</span></span><br><span class="line">      <span class="comment">// s0_vaddr   用的是vaddr</span></span><br><span class="line"></span><br><span class="line">      when (wen) &#123;</span><br><span class="line">        dataArray.write(mem_idx, tl_out.d.bits.data)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableICacheDelay)</span><br><span class="line">        s2_dout(i) := dataArray.read(<span class="type">RegNext</span>(mem_idx), <span class="type">RegNext</span>(!wen &amp;&amp; s0_ren)) <span class="comment">// 下一拍才读dataArray</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        s2_dout(i) := <span class="type">RegNext</span>(dataArray.read(mem_idx, !wen &amp;&amp; s0_ren)) <span class="comment">// 这一拍读dataArray,下一拍送出来</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use two banks, interleaved.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataArraysB0 = dataArrays.take(nWays) <span class="comment">// 取出前面nWays个元素放入新Map</span></span><br><span class="line">    <span class="keyword">val</span> dataArraysB1 = dataArrays.drop(nWays) <span class="comment">// 把前面nWays个元素删除，留下后nWays个元素</span></span><br><span class="line">    require (nBanks == <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bank0 row&#x27;s id wraps around if Bank1 is the starting bank.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b0Row</span></span>(addr: <span class="type">UInt</span>) =</span><br><span class="line">      <span class="keyword">if</span> (refillsToOneBank) &#123;</span><br><span class="line">        addr(untagBits<span class="number">-1</span>, blockOffBits-log2Ceil(refillCycles)+<span class="number">1</span>) + bank(addr)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr(untagBits<span class="number">-1</span>, blockOffBits-log2Ceil(refillCycles)) + bank(addr)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// Bank1 row&#x27;s id stays the same regardless of which Bank has the fetch address.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b1Row</span></span>(addr: <span class="type">UInt</span>) =</span><br><span class="line">      <span class="keyword">if</span> (refillsToOneBank) &#123;</span><br><span class="line">        addr(untagBits<span class="number">-1</span>, blockOffBits-log2Ceil(refillCycles)+<span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr(untagBits<span class="number">-1</span>, blockOffBits-log2Ceil(refillCycles))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    s1_bankid := <span class="type">RegNext</span>(bank(s0_vaddr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until nWays) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// [ tagBits ][ indexBits ][ blockOffBits ] paddr，传入Icache的物理地址</span></span><br><span class="line">      <span class="comment">//    [ indexBits ][lgRC-1][ blockOffBits ] 分Bank的dataArraysBx[x_Ways] 里面的寻址模式</span></span><br><span class="line">      <span class="comment">//  [ indexBits ][ lgRC ]                   refill_idx &lt;&lt; log2Ceil(refillCycles) | refill_cnt对应的字段</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">val</span> s0_ren = s0_valid</span><br><span class="line">      <span class="keyword">val</span> wen = (refill_one_beat &amp;&amp; !invalidated)&amp;&amp; repl_way === i.<span class="type">U</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> mem_idx0: <span class="type">UInt</span> = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">var</span> mem_idx1: <span class="type">UInt</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (refillsToOneBank) &#123;</span><br><span class="line">        <span class="comment">// write a refill beat across only one beat.</span></span><br><span class="line">        mem_idx0 =</span><br><span class="line">          <span class="type">Mux</span>(refill_one_beat, (refill_idx &lt;&lt; (log2Ceil(refillCycles)<span class="number">-1</span>)) | (refill_cnt &gt;&gt; <span class="number">1.</span><span class="type">U</span>),</span><br><span class="line">          b0Row(s0_vaddr))</span><br><span class="line">        mem_idx1 =</span><br><span class="line">          <span class="type">Mux</span>(refill_one_beat, (refill_idx &lt;&lt; (log2Ceil(refillCycles)<span class="number">-1</span>)) | (refill_cnt &gt;&gt; <span class="number">1.</span><span class="type">U</span>),</span><br><span class="line">          b1Row(s0_vaddr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cnt最低位指定使用哪一个bank</span></span><br><span class="line">        when (wen &amp;&amp; refill_cnt(<span class="number">0</span>) === <span class="number">0.</span><span class="type">U</span>) &#123;</span><br><span class="line">          dataArraysB0(i).write(mem_idx0, tl_out.d.bits.data)</span><br><span class="line">        &#125;</span><br><span class="line">        when (wen &amp;&amp; refill_cnt(<span class="number">0</span>) === <span class="number">1.</span><span class="type">U</span>) &#123;</span><br><span class="line">          dataArraysB1(i).write(mem_idx1, tl_out.d.bits.data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// write a refill beat across both banks.</span></span><br><span class="line">        <span class="comment">// 此时refill_idx的最高位被截断</span></span><br><span class="line"></span><br><span class="line">        mem_idx0 =</span><br><span class="line">          <span class="type">Mux</span>(refill_one_beat, (refill_idx &lt;&lt; log2Ceil(refillCycles)) | refill_cnt,</span><br><span class="line">          b0Row(s0_vaddr))</span><br><span class="line">        mem_idx1 =</span><br><span class="line">          <span class="type">Mux</span>(refill_one_beat, (refill_idx &lt;&lt; log2Ceil(refillCycles)) | refill_cnt,</span><br><span class="line">          b1Row(s0_vaddr))</span><br><span class="line"></span><br><span class="line">        when (wen) &#123;</span><br><span class="line">          <span class="keyword">val</span> data = tl_out.d.bits.data</span><br><span class="line">          dataArraysB0(i).write(mem_idx0, data(wordBits/<span class="number">2</span><span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">          dataArraysB1(i).write(mem_idx1, data(wordBits<span class="number">-1</span>, wordBits/<span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableICacheDelay) &#123;</span><br><span class="line">        s2_dout(i) := <span class="type">Cat</span>(dataArraysB1(i).read(<span class="type">RegNext</span>(mem_idx1), <span class="type">RegNext</span>(!wen &amp;&amp; s0_ren)),</span><br><span class="line">                          dataArraysB0(i).read(<span class="type">RegNext</span>(mem_idx0), <span class="type">RegNext</span>(!wen &amp;&amp; s0_ren)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2_dout(i) := <span class="type">RegNext</span>(<span class="type">Cat</span>(dataArraysB1(i).read(mem_idx1, !wen &amp;&amp; s0_ren),</span><br><span class="line">                                  dataArraysB0(i).read(mem_idx0, !wen &amp;&amp; s0_ren)))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> s2_tag_hit = <span class="type">RegNext</span>(s1_tag_hit)</span><br><span class="line">  <span class="keyword">val</span> s2_hit_way = <span class="type">OHToUInt</span>(s2_tag_hit) <span class="comment">// One-hot Vec to UInt</span></span><br><span class="line">  <span class="keyword">val</span> s2_bankid = <span class="type">RegNext</span>(s1_bankid)</span><br><span class="line">  <span class="keyword">val</span> s2_way_mux = <span class="type">Mux1H</span>(s2_tag_hit, s2_dout) <span class="comment">// Mux select valid dout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> s2_unbanked_data = s2_way_mux</span><br><span class="line">  <span class="keyword">val</span> sz = s2_way_mux.getWidth</span><br><span class="line">  <span class="keyword">val</span> s2_bank0_data = s2_way_mux(sz/<span class="number">2</span><span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> s2_bank1_data = s2_way_mux(sz<span class="number">-1</span>,sz/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整顺序，拼接出返回值</span></span><br><span class="line">  <span class="keyword">val</span> s2_data =</span><br><span class="line">    <span class="keyword">if</span> (nBanks == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">Mux</span>(s2_bankid,</span><br><span class="line">        <span class="type">Cat</span>(s2_bank0_data, s2_bank1_data),</span><br><span class="line">        <span class="type">Cat</span>(s2_bank1_data, s2_bank0_data))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s2_unbanked_data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  io.resp.bits.ae := <span class="type">DontCare</span></span><br><span class="line">  io.resp.bits.replay := <span class="type">DontCare</span></span><br><span class="line">  io.resp.bits.data := s2_data</span><br><span class="line">  io.resp.valid := s2_valid &amp;&amp; s2_hit</span><br><span class="line"></span><br><span class="line">  tl_out.a.valid := s2_miss &amp;&amp; !refill_valid &amp;&amp; !io.s2_kill</span><br><span class="line">  tl_out.a.bits := edge_out.<span class="type">Get</span>(</span><br><span class="line">    fromSource = <span class="number">0.</span><span class="type">U</span>,</span><br><span class="line">    toAddress = (refill_paddr &gt;&gt; blockOffBits) &lt;&lt; blockOffBits,</span><br><span class="line">    lgSize = lgCacheBlockBytes.<span class="type">U</span>)._2</span><br><span class="line">  tl_out.b.ready := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">  tl_out.c.valid := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  tl_out.e.valid := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line"></span><br><span class="line">  io.perf.acquire := tl_out.a.fire</span><br><span class="line"></span><br><span class="line">  when (!refill_valid) &#123; invalidated := <span class="literal">false</span>.<span class="type">B</span> &#125; <span class="comment">// refill_valid 则 invalidated</span></span><br><span class="line">  when (refill_fire) &#123; refill_valid := <span class="literal">true</span>.<span class="type">B</span> &#125;   <span class="comment">// refill_fire 则 refill_valid</span></span><br><span class="line">  when (refill_done) &#123; refill_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;  <span class="comment">// refill_done 则 !refill_valid</span></span><br></pre></td></tr></table></figure><h2 id="sub-banking-and-interleaving"><a class="markdownIt-Anchor" href="#sub-banking-and-interleaving"></a> Sub-Banking and interleaving</h2><p>Sub-Banking(Multi-Banking)设计最早用于减少能耗，将<code>data memory array</code>分解为多个独立的bank，原来需要访问一个BlockSize大小的数据，现在只需要访问BlockSize/nBank大小的数据，能耗降低为原来的1/nBank。架构图如下所示:<br /><img src="/images/sub-Banking.png" alt="" /><br />在此基础上，在Multi-Bank的Cache上进行交叉编址，就可以实现对外提供多端口的Multi-port Cache(MB)。如果划分为C个bank,那么这样设计的Cache可以对外同时提供C次命中，从而提高了Cache的带宽。因为对于处理器而言，这些Cache Bank是同步可见的，对这些Cache Bank的读操作也是同步的。这意味着在一个周期内，处理器可以用多个读操作去同时访问这些Bank内的Cache Line。这种实现被称为水平交叠。<br /><img src="/images/horizontal-interleaving.png" alt="horizontal interleaving" /><br />Cache Line interleaving 的根本问题是：在Multi-Banking的Cache上，每个CacheLine(CacheBlock)放置在哪一个Bank内？假设地址的<code>Index</code>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>位，那么在未分Bank的Cache设计中，共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">L=2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>个CacheLine。我们有多种切分Bank的方法，分别如b,c,d所示。</p><ol><li>( b )图，按Index的最高位(Index[N-1])进行分割。此时Index[N-1]决定使用哪一个Bank，Index[N-2,0]在Bank内进行索引。在这种分Bank设计下，除了4个边界CacheLine，Index为X的CacheLine在同一个Bank中与Indedx为X+1,X-1的CacheLine相邻。</li><li>( c )图，按Index的最低位(Index[0])进行分割。此时Index[0]决定使用哪一个Bank，Inde[N-1,1]在Bank内进行索引。在这种分Bank设计下，Index为X的CacheLinie和Index为X+1,X-1的CacheLine一定位于不同的两个Bank上。</li><li>( d )图，按Index[1]进行分割。分析类似，省略。<br />我们把第2种交叉编制方案( c )图称为垂直交叠<br /><img src="/images/Interleaving.png" alt="Interleaving" /></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>BOOM的ICache采用了分Bank技术（也可以配置为不分Bank），目前的框架只支持分为2个Bank。在该ICache的设计中，在TL refill的时候，不同refill_cnt会保存到不同的dataArray地址处，Refill的机制需要在TlieLink中学习。其次，在寻址Mem_idx的时候，同时使用到了vaddr和paddr,这一部分内容需要在TLB中学习。最让人迷惑的就是Mem_idx的生成，由于其牵扯到Refill机制和虚实地址，需要了解这两部分的内容后再进行理解。</p><p><strong>以上です。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;riscv-boom-icache&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#riscv-boom-icache&quot;&gt;&lt;/a&gt; RISCV-BOOM ICACHE&lt;/h1&gt;
&lt;p&gt;在RISCV-BOOM(2)中，我们对BOOM的前端代</summary>
      
    
    
    
    <category term="Computer Architecture" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/"/>
    
    <category term="RISCV-BOOM" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/RISCV-BOOM/"/>
    
    
    <category term="Code Reading" scheme="https://taosicheng2001.github.io/tags/Code-Reading/"/>
    
  </entry>
  
  <entry>
    <title>RISCV-BOOM(2)</title>
    <link href="https://taosicheng2001.github.io/2024/04/07/RISCV-BOOM-2/"/>
    <id>https://taosicheng2001.github.io/2024/04/07/RISCV-BOOM-2/</id>
    <published>2024-04-07T05:46:00.000Z</published>
    <updated>2024-05-05T15:00:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riscv-boom-front-end"><a class="markdownIt-Anchor" href="#riscv-boom-front-end"></a> RISCV-BOOM Front-End</h1><p><img src="/images/front-end.svg" alt="BOOM Front-End" /><br />整体代码位于<code>src/main/scala/ifu</code>，其中<code>frontend.scale</code>为最顶层，<code>icache.scala</code>实现指令缓存，<code>fetch-buffer.scala</code>实现取指缓冲区，<code>fetch-target-queue.scala</code>干啥呢？,<code>bpd</code>目录下的文件实现分支预测</p><h2 id="代码阅读"><a class="markdownIt-Anchor" href="#代码阅读"></a> 代码阅读</h2><p>首先从最顶层入手，在<code>BoomFrontend</code>类中实例化了前端的所有部件，下面进行一层一层的分析</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoomFrontend</span>(<span class="params">val icacheParams: <span class="type">ICacheParams</span>, staticIdForMetadataUseOnly: <span class="type">Int</span></span>)(<span class="params">implicit p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">LazyModule</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> module = <span class="keyword">new</span> <span class="type">BoomFrontendModule</span>(<span class="keyword">this</span>) <span class="comment">// 实例化Module，传入当前BoomFrontend实例作为参数</span></span><br><span class="line">  <span class="keyword">val</span> icache = <span class="type">LazyModule</span>(<span class="keyword">new</span> boom.ifu.<span class="type">ICache</span>(icacheParams, staticIdForMetadataUseOnly)) <span class="comment">// 实例化Icache</span></span><br><span class="line">  <span class="keyword">val</span> masterNode = icache.masterNode <span class="comment">// 实例化 Icache的MasterNode</span></span><br><span class="line">  <span class="keyword">val</span> resetVectorSinkNode = <span class="type">BundleBridgeSink</span>[<span class="type">UInt</span>](<span class="type">Some</span>(() =&gt;</span><br><span class="line">    <span class="type">UInt</span>(masterNode.edges.out.head.bundle.addressBits.<span class="type">W</span>))) <span class="comment">// 实例化resetVectorSinkNode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boomfrontendmodule"><a class="markdownIt-Anchor" href="#boomfrontendmodule"></a> <code>BoomFrontendModule</code></h3><p><code>module</code>通过<code>BoomFrontendModule</code>接口进行实例化，该模块处理了IO连线和前端的五段流水，我们一步步进行分析</p><h4 id="io连线"><a class="markdownIt-Anchor" href="#io连线"></a> IO连线</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">BoomFrontendBundle</span>(outer))</span><br><span class="line"><span class="keyword">val</span> io_reset_vector = outer.resetVectorSinkNode.bundle</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> edge = outer.masterNode.edges.out(<span class="number">0</span>)</span><br><span class="line">require(fetchWidth*coreInstBytes == outer.icacheParams.fetchBytes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bpd = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BranchPredictor</span>)</span><br><span class="line">bpd.io.f3_fire := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line"><span class="keyword">val</span> ras = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BoomRAS</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> icache = outer.icache.module</span><br><span class="line">icache.io.invalidate := io.cpu.flush_icache</span><br><span class="line"><span class="keyword">val</span> tlb = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">TLB</span>(<span class="literal">true</span>, log2Ceil(fetchBytes), <span class="type">TLBConfig</span>(nTLBSets, nTLBWays)))</span><br><span class="line">io.ptw &lt;&gt; tlb.io.ptw</span><br><span class="line">io.cpu.perf.tlbMiss := io.ptw.req.fire</span><br><span class="line">io.cpu.perf.acquire := icache.io.perf.acquire</span><br></pre></td></tr></table></figure><p>首先实例化的是<code>BoomFrontendBundle</code>这一IO变量，这个IO包含<code>BoomFrontedIO</code>和<code>TLBPTWIO</code>。<code>BoomFrontedIO</code>是前端和CPU之间的通信IO；<code>TLBPTWIO</code>是TLB和PTW之间的通信IO，涉及CPU虚拟地址向物理地址转化的过程。<code>BranchPredictor()</code>和<code>BoomRAS()</code>分别实例化分支预测器和返回值栈，<code>icache</code>在前面已经实例化过，这里直接引用，<code>TLB()</code>实例化快表。</p><h4 id="f0-nextpc-select"><a class="markdownIt-Anchor" href="#f0-nextpc-select"></a> F0 (NextPC Select)</h4><p>前端流水的第一个阶段，主要任务是向ICache发起取指请求。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stage0 初始化所有信号，基本都设置为0</span></span><br><span class="line"><span class="keyword">val</span> s0_vpc       = <span class="type">WireInit</span>(<span class="number">0.</span><span class="type">U</span>(vaddrBitsExtended.<span class="type">W</span>))  <span class="comment">// Virtual Program Counter</span></span><br><span class="line"><span class="keyword">val</span> s0_ghist     = <span class="type">WireInit</span>((<span class="number">0.</span><span class="type">U</span>).asTypeOf(<span class="keyword">new</span> <span class="type">GlobalHistory</span>)) <span class="comment">// Global History </span></span><br><span class="line"><span class="keyword">val</span> s0_tsrc      = <span class="type">WireInit</span>(<span class="number">0.</span><span class="type">U</span>(<span class="type">BSRC_SZ</span>.<span class="type">W</span>)) <span class="comment">// &quot;tsrc provides the prediction TO this packet&quot; </span></span><br><span class="line"><span class="keyword">val</span> s0_valid     = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// 合法标志位 默认为false</span></span><br><span class="line"><span class="keyword">val</span> s0_is_replay = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// 重播标志位 默认为false</span></span><br><span class="line"><span class="keyword">val</span> s0_is_sfence = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// sfence标志位 默认为false</span></span><br><span class="line"><span class="keyword">val</span> s0_replay_resp = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">TLBResp</span>) </span><br><span class="line"><span class="keyword">val</span> s0_replay_bpd_resp = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">BranchPredictionBundle</span>)</span><br><span class="line"><span class="keyword">val</span> s0_replay_ppc  = <span class="type">Wire</span>(<span class="type">UInt</span>())</span><br><span class="line"><span class="keyword">val</span> s0_s1_use_f3_bpd_resp = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line"></span><br><span class="line">when (<span class="type">RegNext</span>(reset.asBool) &amp;&amp; !reset.asBool) &#123; </span><br><span class="line">  <span class="comment">// 声明一个寄存器，将reset作为寄存器的输入信号，reset应当是一个全局的复位信号</span></span><br><span class="line">  <span class="comment">// 当reset信号上一个周期为真且当前周期为假时执行该代码段</span></span><br><span class="line">  </span><br><span class="line">  s0_valid   := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">  s0_vpc     := io_reset_vector <span class="comment">// 把vpc复位到特定值</span></span><br><span class="line">  s0_ghist   := (<span class="number">0.</span><span class="type">U</span>).asTypeOf(<span class="keyword">new</span> <span class="type">GlobalHistory</span>)</span><br><span class="line">  s0_tsrc    := <span class="type">BSRC_C</span> <span class="comment">// 设置为 core branch resolution 状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向icache传入当前有效标志位和vpc</span></span><br><span class="line">icache.io.req.valid     := s0_valid</span><br><span class="line">icache.io.req.bits.addr := s0_vpc</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向bpd传入当前有效标志位，vpc和全局历史记录</span></span><br><span class="line">bpd.io.f0_req.valid      := s0_valid</span><br><span class="line">bpd.io.f0_req.bits.pc    := s0_vpc</span><br><span class="line">bpd.io.f0_req.bits.ghist := s0_ghist</span><br></pre></td></tr></table></figure><h4 id="f1-icache-access"><a class="markdownIt-Anchor" href="#f1-icache-access"></a> F1 (ICache Access)</h4><p>前端流水的第二个阶段，主要任务是(1)利用vpc访问TLB,获取ppc (2)利用ppc访问ICache (3)利用bpd Resp计算出是否重定向以及下一个取指的vpc (4)更新流水段的时序逻辑信号</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把上一阶段的寄存器值传递到这一阶段的寄存器中</span></span><br><span class="line"><span class="keyword">val</span> s1_vpc       = <span class="type">RegNext</span>(s0_vpc)</span><br><span class="line"><span class="keyword">val</span> s1_valid     = <span class="type">RegNext</span>(s0_valid, <span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// 默认初始值为false</span></span><br><span class="line"><span class="keyword">val</span> s1_ghist     = <span class="type">RegNext</span>(s0_ghist)</span><br><span class="line"><span class="keyword">val</span> s1_is_replay = <span class="type">RegNext</span>(s0_is_replay)</span><br><span class="line"><span class="keyword">val</span> s1_is_sfence = <span class="type">RegNext</span>(s0_is_sfence)</span><br><span class="line"><span class="keyword">val</span> f1_clear     = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>) </span><br><span class="line"><span class="keyword">val</span> s1_tsrc      = <span class="type">RegNext</span>(s0_tsrc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问tlb</span></span><br><span class="line">tlb.io.req.valid      := (s1_valid &amp;&amp; !s1_is_replay &amp;&amp; !f1_clear) || s1_is_sfence <span class="comment">// 生成tlb有效标志位</span></span><br><span class="line">tlb.io.req.bits.cmd   := <span class="type">DontCare</span></span><br><span class="line">tlb.io.req.bits.vaddr := s1_vpc      <span class="comment">// 把s1_vpc传给tlb</span></span><br><span class="line">tlb.io.req.bits.passthrough := <span class="literal">false</span>.<span class="type">B</span> <span class="comment">// 默认不passthrough</span></span><br><span class="line">tlb.io.req.bits.size  := log2Ceil(coreInstBytes * fetchWidth).<span class="type">U</span></span><br><span class="line">tlb.io.req.bits.v     := io.ptw.status.v</span><br><span class="line">tlb.io.req.bits.prv   := io.ptw.status.prv</span><br><span class="line">tlb.io.sfence         := <span class="type">RegNext</span>(io.cpu.sfence)</span><br><span class="line">tlb.io.kill           := <span class="literal">false</span>.<span class="type">B</span> <span class="comment">// 默认不kill</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tlb resp</span></span><br><span class="line"><span class="keyword">val</span> s1_tlb_miss = !s1_is_replay &amp;&amp; tlb.io.resp.miss</span><br><span class="line"><span class="keyword">val</span> s1_tlb_resp = <span class="type">Mux</span>(s1_is_replay, <span class="type">RegNext</span>(s0_replay_resp), tlb.io.resp) <span class="comment">// 如果s1需要重播,使用s0阶段的重播resp，否则使用tlb的resp</span></span><br><span class="line"><span class="keyword">val</span> s1_ppc  = <span class="type">Mux</span>(s1_is_replay, <span class="type">RegNext</span>(s0_replay_ppc), tlb.io.resp.paddr) <span class="comment">// 如果s1需要重播,使用s0阶段的重播ppc，否则使用tlb的paddr</span></span><br><span class="line"><span class="comment">// bpd resp</span></span><br><span class="line"><span class="keyword">val</span> s1_bpd_resp = bpd.io.resp.f1 <span class="comment">// 获取bpd的resp,后续使用resp进行重定向判断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向icache传入tlb翻译后的physical pc和kill标志位</span></span><br><span class="line">icache.io.s1_paddr := s1_ppc</span><br><span class="line">icache.io.s1_kill  := tlb.io.resp.miss || f1_clear <span class="comment">// 当f1_clear或tlb返回miss时kill</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1_mask = fetchMask(s1_vpc) <span class="comment">// 若fetchWidth为1,则mask为全1</span></span><br><span class="line"><span class="keyword">val</span> f1_redirects = (<span class="number">0</span> until fetchWidth) map &#123; i =&gt;</span><br><span class="line">  s1_valid &amp;&amp; f1_mask(i) &amp;&amp; s1_bpd_resp.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">  (s1_bpd_resp.preds(i).is_jal ||</span><br><span class="line">    (s1_bpd_resp.preds(i).is_br &amp;&amp; s1_bpd_resp.preds(i).taken))</span><br><span class="line">&#125; <span class="comment">// 生成一个重定向标志位列表，对每个取指的指令检查 取掩码后是否合法，分支预测的PC是否合法，分支预测的指令是否是无条件跳转或Taken的有条件跳转</span></span><br><span class="line"><span class="keyword">val</span> f1_redirect_idx = <span class="type">PriorityEncoder</span>(f1_redirects) <span class="comment">// 选择出重定向标志位列表中最先的1,这个idx指向最早的一个分支重定向指令</span></span><br><span class="line"><span class="keyword">val</span> f1_do_redirect = f1_redirects.reduce(_||_) &amp;&amp; useBPD.<span class="type">B</span> <span class="comment">// 归约重定向标志位列表，判断是否需要重定向</span></span><br><span class="line"><span class="keyword">val</span> f1_targs = s1_bpd_resp.preds.map(_.predicted_pc.bits) <span class="comment">// 将predicted_pc成员的bits取出来组成target列表</span></span><br><span class="line"><span class="keyword">val</span> f1_predicted_target = <span class="type">Mux</span>(f1_do_redirect,</span><br><span class="line">                              f1_targs(f1_redirect_idx),</span><br><span class="line">                              nextFetch(s1_vpc))  <span class="comment">// 生成下一个取指目标，跳转or顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新GlobalHistory 方法参数分别为 branches, cfi_taken, cfi_is_br, cfi_idx, cfi_valid, addr, cfi_is_call, cfi_is_ret </span></span><br><span class="line"><span class="keyword">val</span> f1_predicted_ghist = s1_ghist.update(</span><br><span class="line">  s1_bpd_resp.preds.map(p =&gt; p.is_br &amp;&amp; p.predicted_pc.valid).asUInt &amp; f1_mask,  <span class="comment">//branches 生成分支标志位列表</span></span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).taken &amp;&amp; f1_do_redirect,    <span class="comment">// cfi_taken</span></span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).is_br,  <span class="comment">// cfi_is_br</span></span><br><span class="line">  f1_redirect_idx, <span class="comment">// cfi_idx</span></span><br><span class="line">  f1_do_redirect, <span class="comment">// cfi_valid</span></span><br><span class="line">  s1_vpc, <span class="comment">// addr</span></span><br><span class="line">  <span class="literal">false</span>.<span class="type">B</span>, <span class="comment">// cfi_is_call</span></span><br><span class="line">  <span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// cfi_is_ret</span></span><br><span class="line"></span><br><span class="line">when (s1_valid &amp;&amp; !s1_tlb_miss) &#123; <span class="comment">// 设置s0信号，配合RegNext函数，这些值将在下一个时钟周期有效</span></span><br><span class="line">  <span class="comment">// Stop fetching on fault</span></span><br><span class="line">  s0_valid     := !(s1_tlb_resp.ae.inst || s1_tlb_resp.pf.inst)</span><br><span class="line">  s0_tsrc      := <span class="type">BSRC_1</span></span><br><span class="line">  s0_vpc       := f1_predicted_target <span class="comment">// 使用分支预测的结果</span></span><br><span class="line">  s0_ghist     := f1_predicted_ghist  <span class="comment">// 更新分支预测全局历史</span></span><br><span class="line">  s0_is_replay := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="f2-icache-response"><a class="markdownIt-Anchor" href="#f2-icache-response"></a> F2 (ICache Response)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s2_valid = <span class="type">RegNext</span>(s1_valid &amp;&amp; !f1_clear, <span class="literal">false</span>.<span class="type">B</span>) <span class="comment">// 默认非Valid，等待置起为有效</span></span><br><span class="line"><span class="keyword">val</span> s2_vpc   = <span class="type">RegNext</span>(s1_vpc)</span><br><span class="line"><span class="keyword">val</span> s2_ghist = <span class="type">Reg</span>(<span class="keyword">new</span> <span class="type">GlobalHistory</span>)</span><br><span class="line">s2_ghist := s1_ghist</span><br><span class="line"><span class="keyword">val</span> s2_ppc  = <span class="type">RegNext</span>(s1_ppc)</span><br><span class="line"><span class="keyword">val</span> s2_tsrc = <span class="type">RegNext</span>(s1_tsrc) <span class="comment">// tsrc provides the predictor component which provided the prediction TO this instruction</span></span><br><span class="line"><span class="keyword">val</span> s2_fsrc = <span class="type">WireInit</span>(<span class="type">BSRC_1</span>) <span class="comment">// fsrc provides the predictor component which provided the prediction FROM this instruction</span></span><br><span class="line"><span class="keyword">val</span> f2_clear = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line"><span class="keyword">val</span> s2_tlb_resp = <span class="type">RegNext</span>(s1_tlb_resp)</span><br><span class="line"><span class="keyword">val</span> s2_tlb_miss = <span class="type">RegNext</span>(s1_tlb_miss)</span><br><span class="line"><span class="keyword">val</span> s2_is_replay = <span class="type">RegNext</span>(s1_is_replay) &amp;&amp; s2_valid</span><br><span class="line"><span class="keyword">val</span> s2_xcpt = s2_valid &amp;&amp; (s2_tlb_resp.ae.inst || s2_tlb_resp.pf.inst) &amp;&amp; !s2_is_replay</span><br><span class="line"><span class="keyword">val</span> f3_ready = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">icache.io.s2_kill := s2_xcpt</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f2_bpd_resp = bpd.io.resp.f2 <span class="comment">// 这里还能拿回resp的f2?那看来是bpd那边会有一个FIFO？</span></span><br><span class="line"><span class="keyword">val</span> f2_mask = fetchMask(s2_vpc)</span><br><span class="line"><span class="keyword">val</span> f2_redirects = (<span class="number">0</span> until fetchWidth) map &#123; i =&gt;</span><br><span class="line">  s2_valid &amp;&amp; f2_mask(i) &amp;&amp; f2_bpd_resp.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">  (f2_bpd_resp.preds(i).is_jal ||</span><br><span class="line">    (f2_bpd_resp.preds(i).is_br &amp;&amp; f2_bpd_resp.preds(i).taken))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> f2_redirect_idx = <span class="type">PriorityEncoder</span>(f2_redirects)</span><br><span class="line"><span class="keyword">val</span> f2_targs = f2_bpd_resp.preds.map(_.predicted_pc.bits)</span><br><span class="line"><span class="keyword">val</span> f2_do_redirect = f2_redirects.reduce(_||_) &amp;&amp; useBPD.<span class="type">B</span></span><br><span class="line"><span class="keyword">val</span> f2_predicted_target = <span class="type">Mux</span>(f2_do_redirect,</span><br><span class="line">                              f2_targs(f2_redirect_idx),</span><br><span class="line">                              nextFetch(s2_vpc))</span><br><span class="line"><span class="keyword">val</span> f2_predicted_ghist = s2_ghist.update(</span><br><span class="line">  f2_bpd_resp.preds.map(p =&gt; p.is_br &amp;&amp; p.predicted_pc.valid).asUInt &amp; f2_mask,</span><br><span class="line">  f2_bpd_resp.preds(f2_redirect_idx).taken &amp;&amp; f2_do_redirect,</span><br><span class="line">  f2_bpd_resp.preds(f2_redirect_idx).is_br,</span><br><span class="line">  f2_redirect_idx,</span><br><span class="line">  f2_do_redirect,</span><br><span class="line">  s2_vpc,</span><br><span class="line">  <span class="literal">false</span>.<span class="type">B</span>,</span><br><span class="line">  <span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// f2_predicted_ghist 设置</span></span><br><span class="line"><span class="keyword">val</span> f2_correct_f1_ghist = s1_ghist =/= f2_predicted_ghist &amp;&amp; enableGHistStallRepair.<span class="type">B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若s2有效且icache的resp无效 或 s2有效且icache的resp有效且f3未准备好</span></span><br><span class="line">when ((s2_valid &amp;&amp; !icache.io.resp.valid) ||</span><br><span class="line">      (s2_valid &amp;&amp; icache.io.resp.valid &amp;&amp; !f3_ready)) &#123;</span><br><span class="line">  s0_valid := (!s2_tlb_resp.ae.inst &amp;&amp; !s2_tlb_resp.pf.inst) || s2_is_replay || s2_tlb_miss</span><br><span class="line">  s0_vpc   := s2_vpc</span><br><span class="line">  s0_is_replay := s2_valid &amp;&amp; icache.io.resp.valid <span class="comment">// f3未准备好的话，就要让s0_replay?</span></span><br><span class="line">  <span class="comment">// When this is not a replay (it queried the BPDs, we should use f3 resp in the replaying s1)</span></span><br><span class="line">  s0_s1_use_f3_bpd_resp := !s2_is_replay</span><br><span class="line">  s0_ghist := s2_ghist</span><br><span class="line">  s0_tsrc  := s2_tsrc</span><br><span class="line">  f1_clear := <span class="literal">true</span>.<span class="type">B</span>   <span class="comment">// 置位了f1_clear!</span></span><br><span class="line">&#125; .elsewhen (s2_valid &amp;&amp; f3_ready) &#123;</span><br><span class="line">  when (s1_valid &amp;&amp; s1_vpc === f2_predicted_target &amp;&amp; !f2_correct_f1_ghist) &#123;</span><br><span class="line">    <span class="comment">// f2_predicted_target 使用当前指令的vpc(现在是s2_vpc)返回的bpd_resp进行预测，s1_vpc是下一条指令的vpc，在此处判断两者是否相等</span></span><br><span class="line">    <span class="comment">// We trust our prediction of what the global history for the next branch should be</span></span><br><span class="line">    s2_ghist := f2_predicted_ghist</span><br><span class="line">  &#125;</span><br><span class="line">  when ((s1_valid &amp;&amp; (s1_vpc =/= f2_predicted_target || f2_correct_f1_ghist)) || !s1_valid) &#123;</span><br><span class="line">    f1_clear := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line"></span><br><span class="line">    s0_valid     := !((s2_tlb_resp.ae.inst || s2_tlb_resp.pf.inst) &amp;&amp; !s2_is_replay)</span><br><span class="line">    s0_vpc       := f2_predicted_target</span><br><span class="line">    s0_is_replay := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">    s0_ghist     := f2_predicted_ghist</span><br><span class="line">    s2_fsrc      := <span class="type">BSRC_2</span></span><br><span class="line">    s0_tsrc      := <span class="type">BSRC_2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把F2阶段的信号转回F1阶段</span></span><br><span class="line">s0_replay_bpd_resp := f2_bpd_resp</span><br><span class="line">s0_replay_resp := s2_tlb_resp</span><br><span class="line">s0_replay_ppc  := s2_ppc</span><br></pre></td></tr></table></figure><h4 id="f3"><a class="markdownIt-Anchor" href="#f3"></a> F3</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> f3_clear = <span class="type">WireInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    Pipe模式下，整个队列以流水线的状态流动,也就是读入和写出可以在同一个周期内先后完成</span></span><br><span class="line"><span class="comment">    if (pipe) &#123;</span></span><br><span class="line"><span class="comment">        when(io.deq.ready) &#123; io.enq.ready := true.B &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Flow模式下，输入可以在同一个周期内被输出使用（输出端口直接使用输入）</span></span><br><span class="line"><span class="comment">    if (flow) &#123;</span></span><br><span class="line"><span class="comment">        when(io.enq.valid) &#123; io.deq.valid := true.B &#125;</span></span><br><span class="line"><span class="comment">        when(empty) &#123;</span></span><br><span class="line"><span class="comment">            io.deq.bits := io.enq.bits</span></span><br><span class="line"><span class="comment">            do_deq := false.B</span></span><br><span class="line"><span class="comment">        when(io.deq.ready) &#123; do_enq := false.B &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * &quot;decoupled&quot; interface: &#x27;valid&#x27; indicates that the producer has</span></span><br><span class="line"><span class="comment">  * put valid data in &#x27;bits&#x27;, and &#x27;ready&#x27; indicates that the consumer is ready</span></span><br><span class="line"><span class="comment">  * to accept the data this cycle. &#x27;fire&#x27; indicates if IO is both ready and valid</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// IMem Response Queue</span></span><br><span class="line">  <span class="keyword">val</span> f3 = withReset(reset.asBool || f3_clear) &#123;</span><br><span class="line">    <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>(<span class="keyword">new</span> <span class="type">FrontendResp</span>, <span class="number">1</span>, pipe=<span class="literal">true</span>, flow=<span class="literal">false</span>)) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue up the bpd resp as well, incase f4 backpressures f3</span></span><br><span class="line">  <span class="comment">// This is &quot;flow&quot; because the response (enq) arrives in f3, not f2</span></span><br><span class="line">  <span class="keyword">val</span> f3_bpd_resp = withReset(reset.asBool || f3_clear) &#123;</span><br><span class="line">    <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>(<span class="keyword">new</span> <span class="type">BranchPredictionBundle</span>, <span class="number">1</span>, pipe=<span class="literal">true</span>, flow=<span class="literal">true</span>)) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f4_ready = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line">  f3_ready := f3.io.enq.ready <span class="comment">// f3是否ready要看IMem队列入队是否就绪(是否可以接受入队数据)</span></span><br><span class="line">  f3.io.enq.valid   := (s2_valid &amp;&amp; !f2_clear &amp;&amp;</span><br><span class="line">    (icache.io.resp.valid || ((s2_tlb_resp.ae.inst || s2_tlb_resp.pf.inst) &amp;&amp; !s2_tlb_miss))</span><br><span class="line">  ) <span class="comment">// IMem队列入队是否有效,要看F2阶段的操作是否合法(自然把数据放到正确位置了)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//连接s2的数据到IMem队列</span></span><br><span class="line">  f3.io.enq.bits.pc := s2_vpc</span><br><span class="line">  f3.io.enq.bits.data  := <span class="type">Mux</span>(s2_xcpt, <span class="number">0.</span><span class="type">U</span>, icache.io.resp.bits.data)</span><br><span class="line">  f3.io.enq.bits.ghist := s2_ghist</span><br><span class="line">  f3.io.enq.bits.mask := fetchMask(s2_vpc)</span><br><span class="line">  f3.io.enq.bits.xcpt := s2_tlb_resp</span><br><span class="line">  f3.io.enq.bits.fsrc := s2_fsrc</span><br><span class="line">  f3.io.enq.bits.tsrc := s2_tsrc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RAS takes a cycle to read</span></span><br><span class="line">  <span class="keyword">val</span> ras_read_idx = <span class="type">RegInit</span>(<span class="number">0.</span><span class="type">U</span>(log2Ceil(nRasEntries).<span class="type">W</span>))</span><br><span class="line">  ras.io.read_idx := ras_read_idx</span><br><span class="line">  when (f3.io.enq.fire) &#123;</span><br><span class="line">    ras_read_idx := f3.io.enq.bits.ghist.ras_idx</span><br><span class="line">    ras.io.read_idx := f3.io.enq.bits.ghist.ras_idx</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The BPD resp comes in f3</span></span><br><span class="line">  f3_bpd_resp.io.enq.valid := f3.io.deq.valid &amp;&amp; <span class="type">RegNext</span>(f3.io.enq.ready) <span class="comment">// 上一拍入队就绪(可接受入队数据)，这一拍出队已合法(数据可以出去)</span></span><br><span class="line">  f3_bpd_resp.io.enq.bits  := bpd.io.resp.f3</span><br><span class="line">  when (f3_bpd_resp.io.enq.fire) &#123;</span><br><span class="line">    bpd.io.f3_fire := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// f3两个队列出队要看F4是否就绪 </span></span><br><span class="line">  f3.io.deq.ready := f4_ready</span><br><span class="line">  f3_bpd_resp.io.deq.ready := f4_ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f3_imemresp     = f3.io.deq.bits</span><br><span class="line">  <span class="keyword">val</span> f3_bank_mask    = bankMask(f3_imemresp.pc)</span><br><span class="line">  <span class="keyword">val</span> f3_data         = f3_imemresp.data <span class="comment">// 来自Imemresp的一个64bit的数据</span></span><br><span class="line">  <span class="keyword">val</span> f3_aligned_pc   = bankAlign(f3_imemresp.pc)</span><br><span class="line">  <span class="keyword">val</span> f3_is_last_bank_in_block = isLastBankInBlock(f3_aligned_pc)</span><br><span class="line">  <span class="keyword">val</span> f3_is_rvc       = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_redirects    = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_targs        = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">UInt</span>(vaddrBitsExtended.<span class="type">W</span>)))</span><br><span class="line">  <span class="keyword">val</span> f3_cfi_types    = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">UInt</span>(<span class="type">CFI_SZ</span>.<span class="type">W</span>)))</span><br><span class="line">  <span class="keyword">val</span> f3_shadowed_mask = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_fetch_bundle = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">FetchBundle</span>)</span><br><span class="line">  <span class="keyword">val</span> f3_mask         = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_br_mask      = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_call_mask    = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_ret_mask     = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_npc_plus4_mask = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line">  <span class="keyword">val</span> f3_btb_mispredicts = <span class="type">Wire</span>(<span class="type">Vec</span>(fetchWidth, <span class="type">Bool</span>()))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// f3_fetch_bundle </span></span><br><span class="line">  f3_fetch_bundle.mask := f3_mask.asUInt</span><br><span class="line">  f3_fetch_bundle.br_mask := f3_br_mask.asUInt</span><br><span class="line">  f3_fetch_bundle.pc := f3_imemresp.pc</span><br><span class="line">  f3_fetch_bundle.ftq_idx := <span class="number">0.</span><span class="type">U</span> <span class="comment">// This gets assigned later</span></span><br><span class="line">  f3_fetch_bundle.xcpt_pf_if := f3_imemresp.xcpt.pf.inst</span><br><span class="line">  f3_fetch_bundle.xcpt_ae_if := f3_imemresp.xcpt.ae.inst</span><br><span class="line">  f3_fetch_bundle.fsrc := f3_imemresp.fsrc</span><br><span class="line">  f3_fetch_bundle.tsrc := f3_imemresp.tsrc</span><br><span class="line">  f3_fetch_bundle.shadowed_mask := f3_shadowed_mask</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tracks trailing 16b of previous fetch packet</span></span><br><span class="line">  <span class="keyword">val</span> f3_prev_half    = <span class="type">Reg</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="comment">// Tracks if last fetchpacket contained a half-inst</span></span><br><span class="line">  <span class="keyword">val</span> f3_prev_is_half = <span class="type">RegInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line"></span><br><span class="line">  require(fetchWidth &gt;= <span class="number">4</span>) <span class="comment">// Logic gets kind of annoying with fetchWidth = 2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isRVC</span></span>(inst: <span class="type">UInt</span>) = (inst(<span class="number">1</span>,<span class="number">0</span>) =/= <span class="number">3.</span><span class="type">U</span>)</span><br><span class="line">  <span class="keyword">var</span> redirect_found = <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  <span class="keyword">var</span> bank_prev_is_half = f3_prev_is_half</span><br><span class="line">  <span class="keyword">var</span> bank_prev_half    = f3_prev_half</span><br><span class="line">  <span class="keyword">var</span> last_inst = <span class="number">0.</span><span class="type">U</span>(<span class="number">16.</span><span class="type">W</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的硬件都是并行的</span></span><br><span class="line">  <span class="comment">// 这里主要的困难是需要处理 16b和32b指令混合使用时导致非的对齐情况，并且在fetchBuff中确定好每条指令的起始地址</span></span><br><span class="line">  <span class="keyword">for</span> (b &lt;- <span class="number">0</span> until nBanks) &#123; <span class="comment">// 分多个Bank处理,每个b对应每个Bank,0th bank对应f3_data(31,0) 1th bank对应f3_data(63,32)</span></span><br><span class="line">    <span class="keyword">val</span> bank_data  = f3_data((b+<span class="number">1</span>)*bankWidth*<span class="number">16</span><span class="number">-1</span>, b*bankWidth*<span class="number">16</span>) <span class="comment">// data of bank from IMem; bankWidth = fetchWidth / nBanks； 一个b计算一次bank_data，取出bandWith个16b；</span></span><br><span class="line">    <span class="comment">// 实际生成的硬件信号是 wire [63:0] bank_data (after unrolling the loop) ?</span></span><br><span class="line">    <span class="keyword">val</span> bank_mask  = <span class="type">Wire</span>(<span class="type">Vec</span>(bankWidth, <span class="type">Bool</span>()))</span><br><span class="line">    <span class="keyword">val</span> bank_insts = <span class="type">Wire</span>(<span class="type">Vec</span>(bankWidth, <span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))) <span class="comment">// insts of bank from IMem，保存bankWidth条, 每条32位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w &lt;- <span class="number">0</span> until bankWidth) &#123; <span class="comment">// 一个w对应一个16b</span></span><br><span class="line">      <span class="keyword">val</span> i = (b * bankWidth) + w <span class="comment">// i定位到在f3_imemresp中当前指令的具体位置，w是每个bank内部的指令索引，i是整个f的指令索引</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> valid = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line">      <span class="keyword">val</span> bpu = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BreakpointUnit</span>(nBreakpoints)) <span class="comment">// 不知道是啥，看起来像是CheckingPoint?</span></span><br><span class="line">      bpu.io.status   := io.cpu.status</span><br><span class="line">      bpu.io.bp       := io.cpu.bp</span><br><span class="line">      bpu.io.ea       := <span class="type">DontCare</span></span><br><span class="line">      bpu.io.mcontext := io.cpu.mcontext</span><br><span class="line">      bpu.io.scontext := io.cpu.scontext</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> brsigs = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">BranchDecodeSignals</span>)</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="number">0</span>) &#123;  <span class="comment">// 每个Bank的第一条指令</span></span><br><span class="line">        <span class="keyword">val</span> inst0 = <span class="type">Cat</span>(bank_data(<span class="number">15</span>,<span class="number">0</span>), f3_prev_half) <span class="comment">// 上一个尾部16b,可能来自同一个IMemResp, f3_prev_half(f3整体的)，bank_prev_half(每个bank自己的)，</span></span><br><span class="line">        <span class="keyword">val</span> inst1 = bank_data(<span class="number">31</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> exp_inst0 = <span class="type">ExpandRVC</span>(inst0)</span><br><span class="line">        <span class="keyword">val</span> exp_inst1 = <span class="type">ExpandRVC</span>(inst1)</span><br><span class="line">        <span class="keyword">val</span> pc0 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).<span class="type">U</span> - <span class="number">2.</span><span class="type">U</span>)</span><br><span class="line">        <span class="keyword">val</span> pc1 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).<span class="type">U</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> bpd_decoder0 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BranchDecode</span>)</span><br><span class="line">        bpd_decoder0.io.inst := exp_inst0</span><br><span class="line">        bpd_decoder0.io.pc   := pc0</span><br><span class="line">        <span class="keyword">val</span> bpd_decoder1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BranchDecode</span>)</span><br><span class="line">        bpd_decoder1.io.inst := exp_inst1</span><br><span class="line">        bpd_decoder1.io.pc   := pc1</span><br><span class="line"></span><br><span class="line">      when (bank_prev_is_half) &#123; <span class="comment">// 处理半条指令 用inst0</span></span><br><span class="line">          bank_insts(w)                := inst0</span><br><span class="line">          f3_fetch_bundle.insts(i)     := inst0</span><br><span class="line">          f3_fetch_bundle.exp_insts(i) := exp_inst0</span><br><span class="line">          bpu.io.pc                    := pc0</span><br><span class="line">          brsigs                       := bpd_decoder0.io.out</span><br><span class="line">          f3_fetch_bundle.edge_inst(b) := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">          <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123; <span class="comment">// 不是第一个bank</span></span><br><span class="line">            <span class="keyword">val</span> inst0b     = <span class="type">Cat</span>(bank_data(<span class="number">15</span>,<span class="number">0</span>), last_inst) <span class="comment">// </span></span><br><span class="line">            <span class="keyword">val</span> exp_inst0b = <span class="type">ExpandRVC</span>(inst0b)</span><br><span class="line">            <span class="keyword">val</span> bpd_decoder0b = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BranchDecode</span>)</span><br><span class="line">            bpd_decoder0b.io.inst := exp_inst0b</span><br><span class="line">            bpd_decoder0b.io.pc   := pc0</span><br><span class="line"></span><br><span class="line">            when (f3_bank_mask(b<span class="number">-1</span>)) &#123; <span class="comment">// 且前一个bank没屏蔽</span></span><br><span class="line">              bank_insts(w)                := inst0b</span><br><span class="line">              f3_fetch_bundle.insts(i)     := inst0b</span><br><span class="line">              f3_fetch_bundle.exp_insts(i) := exp_inst0b</span><br><span class="line">              brsigs                       := bpd_decoder0b.io.out</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; .otherwise &#123; <span class="comment">// 没有wrap around</span></span><br><span class="line">          bank_insts(w)                := inst1</span><br><span class="line">          f3_fetch_bundle.insts(i)     := inst1</span><br><span class="line">          f3_fetch_bundle.exp_insts(i) := exp_inst1</span><br><span class="line">          bpu.io.pc                    := pc1</span><br><span class="line">          brsigs                       := bpd_decoder1.io.out</span><br><span class="line">          f3_fetch_bundle.edge_inst(b) := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">        &#125;</span><br><span class="line">        valid := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// w != 0</span></span><br><span class="line">        <span class="keyword">val</span> inst = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> exp_inst = <span class="type">ExpandRVC</span>(inst)</span><br><span class="line">        <span class="keyword">val</span> pc = f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).<span class="type">U</span></span><br><span class="line">        <span class="keyword">val</span> bpd_decoder = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BranchDecode</span>) <span class="comment">// 用于解码指令是不是br</span></span><br><span class="line">        <span class="comment">// 插入bpd中</span></span><br><span class="line">        bpd_decoder.io.inst := exp_inst</span><br><span class="line">        bpd_decoder.io.pc   := pc</span><br><span class="line"></span><br><span class="line">        bank_insts(w)                := inst</span><br><span class="line">        f3_fetch_bundle.insts(i)     := inst</span><br><span class="line">        f3_fetch_bundle.exp_insts(i) := exp_inst</span><br><span class="line">        bpu.io.pc                    := pc</span><br><span class="line">        brsigs                       := bpd_decoder.io.out</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// Need special case since 0th instruction may carry over the wrap around</span></span><br><span class="line">          inst  := bank_data(<span class="number">47</span>,<span class="number">16</span>) <span class="comment">//</span></span><br><span class="line">          valid := bank_prev_is_half || !(bank_mask(<span class="number">0</span>) &amp;&amp; !isRVC(bank_insts(<span class="number">0</span>))) <span class="comment">// 如果有half（也就是前16b用于拼接了）或 0th bank_data被屏蔽了或是RVC</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w == bankWidth - <span class="number">1</span>) &#123; <span class="comment">// 已经到最后一个16b了</span></span><br><span class="line">          inst  := <span class="type">Cat</span>(<span class="number">0.</span><span class="type">U</span>(<span class="number">16.</span><span class="type">W</span>), bank_data(bankWidth*<span class="number">16</span><span class="number">-1</span>,(bankWidth<span class="number">-1</span>)*<span class="number">16</span>)) <span class="comment">// 这就是一个合法的16b指令</span></span><br><span class="line">          valid := !((bank_mask(w<span class="number">-1</span>) &amp;&amp; !isRVC(bank_insts(w<span class="number">-1</span>))) ||</span><br><span class="line">            !isRVC(inst)) <span class="comment">// 当下的inst是RVC 且 (前一个指令被屏蔽 或前一个指令是RVC)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          inst  := bank_data(w*<span class="number">16</span>+<span class="number">32</span><span class="number">-1</span>,w*<span class="number">16</span>)</span><br><span class="line">          valid := !(bank_mask(w<span class="number">-1</span>) &amp;&amp; !isRVC(bank_insts(w<span class="number">-1</span>))) <span class="comment">// 前一个指令被屏蔽 或 前一个指令是RVC</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      f3_is_rvc(i) := isRVC(bank_insts(w))  <span class="comment">// 这里会看是不是RVC,即使我们在bank_insts中放置了32bit，在这里也会被发现内部藏了一个16bit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      bank_mask(w) := f3.io.deq.valid &amp;&amp; f3_imemresp.mask(i) &amp;&amp; valid &amp;&amp; !redirect_found <span class="comment">// 一个w对应一个bank_data 和一个bank_mask</span></span><br><span class="line">      f3_mask  (i) := f3.io.deq.valid &amp;&amp; f3_imemresp.mask(i) &amp;&amp; valid &amp;&amp; !redirect_found</span><br><span class="line">      f3_targs (i) := <span class="type">Mux</span>(brsigs.cfi_type === <span class="type">CFI_JALR</span>,  <span class="comment">// JALR指令就走bpd,否则走br</span></span><br><span class="line">        f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.bits,</span><br><span class="line">        brsigs.target)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Flush BTB entries for JALs if we mispredict the target</span></span><br><span class="line">      f3_btb_mispredicts(i) := (brsigs.cfi_type === <span class="type">CFI_JAL</span> &amp;&amp; valid &amp;&amp;</span><br><span class="line">        f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">        (f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.bits =/= brsigs.target)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是不是加4(是不是32bit)</span></span><br><span class="line">      f3_npc_plus4_mask(i) := (<span class="keyword">if</span> (w == <span class="number">0</span>) &#123; </span><br><span class="line">        !f3_is_rvc(i) &amp;&amp; !bank_prev_is_half</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        !f3_is_rvc(i)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">val</span> offset_from_aligned_pc = (</span><br><span class="line">        (i &lt;&lt; <span class="number">1</span>).<span class="type">U</span>((log2Ceil(icBlockBytes)+<span class="number">1</span>).<span class="type">W</span>) +</span><br><span class="line">        brsigs.sfb_offset.bits -</span><br><span class="line">        <span class="type">Mux</span>(bank_prev_is_half &amp;&amp; (w == <span class="number">0</span>).<span class="type">B</span>, <span class="number">2.</span><span class="type">U</span>, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">val</span> lower_mask = <span class="type">Wire</span>(<span class="type">UInt</span>((<span class="number">2</span>*fetchWidth).<span class="type">W</span>))</span><br><span class="line">      <span class="keyword">val</span> upper_mask = <span class="type">Wire</span>(<span class="type">UInt</span>((<span class="number">2</span>*fetchWidth).<span class="type">W</span>))</span><br><span class="line">      lower_mask := <span class="type">UIntToOH</span>(i.<span class="type">U</span>)</span><br><span class="line">      upper_mask := <span class="type">UIntToOH</span>(offset_from_aligned_pc(log2Ceil(fetchBytes)+<span class="number">1</span>,<span class="number">1</span>)) &lt;&lt; <span class="type">Mux</span>(f3_is_last_bank_in_block, bankWidth.<span class="type">U</span>, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line"></span><br><span class="line">      f3_fetch_bundle.sfbs(i) := (</span><br><span class="line">        f3_mask(i) &amp;&amp;</span><br><span class="line">        brsigs.sfb_offset.valid &amp;&amp;</span><br><span class="line">        (offset_from_aligned_pc &lt;= <span class="type">Mux</span>(f3_is_last_bank_in_block, (fetchBytes+bankBytes).<span class="type">U</span>,(<span class="number">2</span>*fetchBytes).<span class="type">U</span>))</span><br><span class="line">      )</span><br><span class="line">      f3_fetch_bundle.sfb_masks(i)       := ~<span class="type">MaskLower</span>(lower_mask) &amp; ~<span class="type">MaskUpper</span>(upper_mask)</span><br><span class="line">      f3_fetch_bundle.shadowable_mask(i) := (!(f3_fetch_bundle.xcpt_pf_if || f3_fetch_bundle.xcpt_ae_if || bpu.io.debug_if || bpu.io.xcpt_if) &amp;&amp;</span><br><span class="line">                                             f3_bank_mask(b) &amp;&amp;</span><br><span class="line">                                             (brsigs.shadowable || !f3_mask(i)))</span><br><span class="line">      f3_fetch_bundle.sfb_dests(i)       := offset_from_aligned_pc</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Redirect if</span></span><br><span class="line">      <span class="comment">//  1) its a JAL/JALR (unconditional)</span></span><br><span class="line">      <span class="comment">//  2) the BPD believes this is a branch and says we should take it</span></span><br><span class="line">      f3_redirects(i)    := f3_mask(i) &amp;&amp; (</span><br><span class="line">        brsigs.cfi_type === <span class="type">CFI_JAL</span> || brsigs.cfi_type === <span class="type">CFI_JALR</span> ||</span><br><span class="line">        (brsigs.cfi_type === <span class="type">CFI_BR</span> &amp;&amp; f3_bpd_resp.io.deq.bits.preds(i).taken &amp;&amp; useBPD.<span class="type">B</span>)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      f3_br_mask(i)   := f3_mask(i) &amp;&amp; brsigs.cfi_type === <span class="type">CFI_BR</span></span><br><span class="line">      f3_cfi_types(i) := brsigs.cfi_type</span><br><span class="line">      f3_call_mask(i) := brsigs.is_call</span><br><span class="line">      f3_ret_mask(i)  := brsigs.is_ret</span><br><span class="line"></span><br><span class="line">      f3_fetch_bundle.bp_debug_if_oh(i) := bpu.io.debug_if</span><br><span class="line">      f3_fetch_bundle.bp_xcpt_if_oh (i) := bpu.io.xcpt_if</span><br><span class="line"></span><br><span class="line">      redirect_found = redirect_found || f3_redirects(i)</span><br><span class="line">    &#125; <span class="comment">// 处理完一行bank后就要更新last_inst</span></span><br><span class="line">    last_inst = bank_insts(bankWidth<span class="number">-1</span>)(<span class="number">15</span>,<span class="number">0</span>) <span class="comment">// 每个bank中的最后一个指令的最后16位(15,0)</span></span><br><span class="line">    bank_prev_is_half = <span class="type">Mux</span>(f3_bank_mask(b),</span><br><span class="line">      (!(bank_mask(bankWidth<span class="number">-2</span>) &amp;&amp; !isRVC(bank_insts(bankWidth<span class="number">-2</span>))) &amp;&amp; !isRVC(last_inst)),  </span><br><span class="line">      bank_prev_is_half)</span><br><span class="line">        <span class="comment">// 怎么样才会是跨边界了的指令呢？ 如果当前bank的掩码为0（根本不使用），那直接继承之前的状态；否则需要查看bank内的情况，(0,0)处被屏蔽掉了或(0,0)是RVC指令，且(0,1)处不是RVC指令</span></span><br><span class="line">    bank_prev_half    = <span class="type">Mux</span>(f3_bank_mask(b),</span><br><span class="line">      last_inst(<span class="number">15</span>,<span class="number">0</span>),</span><br><span class="line">      bank_prev_half)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.cfi_type      := f3_cfi_types(f3_fetch_bundle.cfi_idx.bits)</span><br><span class="line">  f3_fetch_bundle.cfi_is_call   := f3_call_mask(f3_fetch_bundle.cfi_idx.bits)</span><br><span class="line">  f3_fetch_bundle.cfi_is_ret    := f3_ret_mask (f3_fetch_bundle.cfi_idx.bits)</span><br><span class="line">  f3_fetch_bundle.cfi_npc_plus4 := f3_npc_plus4_mask(f3_fetch_bundle.cfi_idx.bits)</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.ghist    := f3.io.deq.bits.ghist</span><br><span class="line">  f3_fetch_bundle.lhist    := f3_bpd_resp.io.deq.bits.lhist</span><br><span class="line">  f3_fetch_bundle.bpd_meta := f3_bpd_resp.io.deq.bits.meta</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.end_half.valid := bank_prev_is_half</span><br><span class="line">  f3_fetch_bundle.end_half.bits  := bank_prev_half</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次f3发射的时候，就把bank的跟踪记录更新到f3整体的跟踪记录上</span></span><br><span class="line">  when (f3.io.deq.fire) &#123;</span><br><span class="line">    f3_prev_is_half := bank_prev_is_half</span><br><span class="line">    f3_prev_half    := bank_prev_half</span><br><span class="line">    assert(f3_bpd_resp.io.deq.bits.pc === f3_fetch_bundle.pc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  when (f3_clear) &#123;</span><br><span class="line">    f3_prev_is_half := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.cfi_idx.valid := f3_redirects.reduce(_||_)</span><br><span class="line">  f3_fetch_bundle.cfi_idx.bits  := <span class="type">PriorityEncoder</span>(f3_redirects)</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.ras_top := ras.io.read_addr</span><br><span class="line">  <span class="comment">// Redirect earlier stages only if the later stage</span></span><br><span class="line">  <span class="comment">// can consume this packet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f3_predicted_target = <span class="type">Mux</span>(f3_redirects.reduce(_||_),</span><br><span class="line">    <span class="type">Mux</span>(f3_fetch_bundle.cfi_is_ret &amp;&amp; useBPD.<span class="type">B</span> &amp;&amp; useRAS.<span class="type">B</span>,</span><br><span class="line">      ras.io.read_addr,</span><br><span class="line">      f3_targs(<span class="type">PriorityEncoder</span>(f3_redirects))</span><br><span class="line">    ),</span><br><span class="line">    nextFetch(f3_fetch_bundle.pc)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  f3_fetch_bundle.next_pc       := f3_predicted_target</span><br><span class="line">  <span class="keyword">val</span> f3_predicted_ghist = f3_fetch_bundle.ghist.update(</span><br><span class="line">    f3_fetch_bundle.br_mask,</span><br><span class="line">    f3_fetch_bundle.cfi_idx.valid,</span><br><span class="line">    f3_fetch_bundle.br_mask(f3_fetch_bundle.cfi_idx.bits),</span><br><span class="line">    f3_fetch_bundle.cfi_idx.bits,</span><br><span class="line">    f3_fetch_bundle.cfi_idx.valid,</span><br><span class="line">    f3_fetch_bundle.pc,</span><br><span class="line">    f3_fetch_bundle.cfi_is_call,</span><br><span class="line">    f3_fetch_bundle.cfi_is_ret</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ras.io.write_valid := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  ras.io.write_addr  := f3_aligned_pc + (f3_fetch_bundle.cfi_idx.bits &lt;&lt; <span class="number">1</span>) + <span class="type">Mux</span>(</span><br><span class="line">    f3_fetch_bundle.cfi_npc_plus4, <span class="number">4.</span><span class="type">U</span>, <span class="number">2.</span><span class="type">U</span>)</span><br><span class="line">  ras.io.write_idx   := <span class="type">WrapInc</span>(f3_fetch_bundle.ghist.ras_idx, nRasEntries)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f3_correct_f1_ghist = s1_ghist =/= f3_predicted_ghist &amp;&amp; enableGHistStallRepair.<span class="type">B</span></span><br><span class="line">  <span class="keyword">val</span> f3_correct_f2_ghist = s2_ghist =/= f3_predicted_ghist &amp;&amp; enableGHistStallRepair.<span class="type">B</span></span><br><span class="line"></span><br><span class="line">  when (f3.io.deq.valid &amp;&amp; f4_ready) &#123;</span><br><span class="line">    when (f3_fetch_bundle.cfi_is_call &amp;&amp; f3_fetch_bundle.cfi_idx.valid) &#123;</span><br><span class="line">      ras.io.write_valid := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">    &#125;</span><br><span class="line">    when (f3_redirects.reduce(_||_)) &#123;</span><br><span class="line">      f3_prev_is_half := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">    &#125;</span><br><span class="line">    when (s2_valid &amp;&amp; s2_vpc === f3_predicted_target &amp;&amp; !f3_correct_f2_ghist) &#123;</span><br><span class="line">      f3.io.enq.bits.ghist := f3_predicted_ghist</span><br><span class="line">    &#125; .elsewhen (!s2_valid &amp;&amp; s1_valid &amp;&amp; s1_vpc === f3_predicted_target &amp;&amp; !f3_correct_f1_ghist) &#123;</span><br><span class="line">      s2_ghist := f3_predicted_ghist</span><br><span class="line">    &#125; .elsewhen (( s2_valid &amp;&amp;  (s2_vpc =/= f3_predicted_target || f3_correct_f2_ghist)) ||</span><br><span class="line">          (!s2_valid &amp;&amp;  s1_valid &amp;&amp; (s1_vpc =/= f3_predicted_target || f3_correct_f1_ghist)) ||</span><br><span class="line">          (!s2_valid &amp;&amp; !s1_valid)) &#123;</span><br><span class="line">      f2_clear := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">      f1_clear := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line"></span><br><span class="line">      s0_valid     := !(f3_fetch_bundle.xcpt_pf_if || f3_fetch_bundle.xcpt_ae_if)</span><br><span class="line">      s0_vpc       := f3_predicted_target</span><br><span class="line">      s0_is_replay := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">      s0_ghist     := f3_predicted_ghist</span><br><span class="line">      s0_tsrc      := <span class="type">BSRC_3</span></span><br><span class="line"></span><br><span class="line">      f3_fetch_bundle.fsrc := <span class="type">BSRC_3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When f3 finds a btb mispredict, queue up a bpd correction update</span></span><br><span class="line">  <span class="keyword">val</span> f4_btb_corrections = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>(<span class="keyword">new</span> <span class="type">BranchPredictionUpdate</span>, <span class="number">2</span>))</span><br><span class="line">  f4_btb_corrections.io.enq.valid := f3.io.deq.fire &amp;&amp; f3_btb_mispredicts.reduce(_||_) &amp;&amp; enableBTBFastRepair.<span class="type">B</span></span><br><span class="line">  f4_btb_corrections.io.enq.bits  := <span class="type">DontCare</span></span><br><span class="line">  f4_btb_corrections.io.enq.bits.is_mispredict_update := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  f4_btb_corrections.io.enq.bits.is_repair_update     := <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">  f4_btb_corrections.io.enq.bits.btb_mispredicts      := f3_btb_mispredicts.asUInt</span><br><span class="line">  f4_btb_corrections.io.enq.bits.pc                   := f3_fetch_bundle.pc</span><br><span class="line">  f4_btb_corrections.io.enq.bits.ghist                := f3_fetch_bundle.ghist</span><br><span class="line">  f4_btb_corrections.io.enq.bits.lhist                := f3_fetch_bundle.lhist</span><br><span class="line">  f4_btb_corrections.io.enq.bits.meta                 := f3_fetch_bundle.bpd_meta</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在f3阶段有一个重要的工作就是对于来自ICache的Response进行拆解分析，区分出RVC(16bits)指令和普通指令(32bits)并放置到<code>fetch_bundle</code>中，方便后续使用，其实现比较复杂难懂，在这里作简要说明。<br /><img src="/images/F3_bank_insts.jpg" alt="" /><br />如上图所示，每个周期，从ICache来的数据<code>f3_data</code>为64bits,将其分为2个Banks,并在循环中用二维索引(w,b)进行表示(当然在循环中只能看到最内层的w，外层的b是隐藏的索引)。在<code>fetch_bundle</code>中，为了用最少的位置存放所有可能的情况，这里将<code>fetch_bundle.insts</code>也按照w,b设置为4项，分别表示以这个位置开头的指令（也就是以<code>f3_data(0)</code>,<code>f3_data(16)</code>,<code>f3_data(32)</code>,<code>f3_data(48)</code>开头的指令），而以这些位置开头的指令是否合法，则使用<code>f3_mask</code>等信号进行控制。在进行拆解的过程中，可能会使用前面“残留的”指令与当前部分指令进行拼接，生成对应指令，具体过程如上图标注。</p><h4 id="f4-f5"><a class="markdownIt-Anchor" href="#f4-f5"></a> F4 &amp; F5</h4><p><strong>TO DO</strong></p><h4 id="关键信号跟踪"><a class="markdownIt-Anchor" href="#关键信号跟踪"></a> 关键信号跟踪</h4><h5 id="sx_valid"><a class="markdownIt-Anchor" href="#sx_valid"></a> <code>sx_valid</code></h5><p><code>sx_valid</code>信号就是每个阶段stage x的使能信号，只有使能信号为<code>true.B</code>时，流水段才可能流动(当然还可能要看其他信号，如<code>fx_clear</code>)，<code>s0_valid</code>信号是一个WireInt类型信号，同时<code>s0_valid</code>信号随着流水线流动，逐步赋值给<code>sx_valid</code>这些Reg类型信号，进而使能对应阶段及其内部的部件</p><ol><li><code>s0_valid</code>作为最初的使能信号，在复位后变为<code>true.B</code>，在F0阶段使能ICache和BPD这两个部件；在如下情形下会被置为<code>false.B</code>：<ul><li>F1阶段：当前指令是ae或pf(通过s1_tlb_resp判断)</li><li>F2阶段：<ul><li>ICache没准备好或F3未准备好：当前指令的TLB命中了，不需要replay，且是ae或pf(通过s2_tlb_miss,s2_is_replay,s2_tlb_resp判断)</li><li>F3已准备好，F2未使能或F2已使能但下条指令和当前指令预测不符合：当前指令不需要replay,且是ae或pf</li></ul></li></ul></li><li><code>s1_valid</code>由<code>s0_valid</code>在新时钟周期到来时更新,在F1阶段中使能TLB部件；</li><li><code>s2_valid</code>由<code>s1_valid</code>在新时钟周期到来时更新</li></ol><h5 id="sx_is_replay"><a class="markdownIt-Anchor" href="#sx_is_replay"></a> <code>sx_is_replay</code></h5><p><code>sx_is_replay</code>信号控制部件进行重复执行操作，如某条指令若在F2阶段发现F3阶段未准备好，其会重新转回F1阶段进行执行。</p><ol><li><code>s0_is_replay</code>是最初的replay信号，复位后变为<code>false.B</code>，在F2阶段中，若F3未准备好，则会被置为<code>true.B</code></li><li><code>s1_is_replay</code>由<code>s0_is_replay</code>在新时钟周期到来时更新，为<code>true.B</code>时：<ul><li>F1阶段：阻塞对tlb请求的使能，选择实际来自F2阶段传入的<code>tlb_resp</code>作为<code>tlb_resp</code>，选择F2阶段传入的<code>tlb_ppc</code>作为<code>tlb_ppc</code></li></ul></li></ol><h5 id="fx_clear"><a class="markdownIt-Anchor" href="#fx_clear"></a> <code>fx_clear</code></h5><p><code>fx_clear</code>信号控制是否刷新流水段</p><ol><li><code>f1_clear</code>在F1阶段阻塞对tlb请求的使能，阻塞<code>s1_valid</code>向<code>s2_valid</code>传播，使能对Icache的s1_kill信号。在如下情况下会被置为<code>true.B</code><ul><li>F2阶段：ICache或F3未准备好；ICache和F3已准备好，但下条指令和当前指令预测不符合</li><li>F3阶段：</li><li>F5阶段：</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;riscv-boom-front-end&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#riscv-boom-front-end&quot;&gt;&lt;/a&gt; RISCV-BOOM Front-End&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/</summary>
      
    
    
    
    <category term="Computer Architecture" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/"/>
    
    <category term="RISCV-BOOM" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/RISCV-BOOM/"/>
    
    
    <category term="Code Reading" scheme="https://taosicheng2001.github.io/tags/Code-Reading/"/>
    
  </entry>
  
  <entry>
    <title>RISCV-BOOM(1)</title>
    <link href="https://taosicheng2001.github.io/2024/04/07/RISCV-BOOM-1/"/>
    <id>https://taosicheng2001.github.io/2024/04/07/RISCV-BOOM-1/</id>
    <published>2024-04-07T04:43:01.000Z</published>
    <updated>2024-05-05T15:00:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riscv-boom-pipeline"><a class="markdownIt-Anchor" href="#riscv-boom-pipeline"></a> RISCV-BOOM Pipeline</h1><h2 id="流水段划分"><a class="markdownIt-Anchor" href="#流水段划分"></a> 流水段划分</h2><p><img src="/images/boom-pipeline.svg" alt="" /><br />RISCV-BOOM概念上划分为<code>Fetch</code>, <code>Decode</code>, <code>Register Rename</code>, <code>Dispatch</code>, <code>Issue</code>, <code>Register Read</code>, <code>Execute</code>, <code>Memory</code>, <code>Writeback</code> 和 <code>Commit</code>阶段;但在其实现时只划分为<code>Fetch</code>, <code>Decode&amp;Rename</code>, <code>Raname&amp;Dispatch</code>, <code>Issue&amp;Register Read</code>, <code>Execute</code>, <code>Memory</code>和<code>Writeback</code>。</p><ol><li>Fetch：把指令从指令存储器（L1ICache及下层Cache）中取出并放入<code>Fetch Buffer</code>。此阶段同时发生分支预测，每条指令都附有一个分支标记，用于标记推测分支</li><li>Decode: 从<code>Fetch Buffer</code>中提取指令并生成<code>Micro-Op(UOP)</code></li><li>Rename: 将逻辑寄存器重命名为物理寄存器</li><li>Dispatch: 把<code>UOP</code>分派到一组<code>Issue Queue(IQ)</code>中</li><li>Issue: 当<code>IQ</code>中的<code>UOP</code>的所有操作数准备就绪后进行发射。<strong>此处是流水段无序部分的开始</strong></li><li>Register Read: 发射的<code>UOP</code>从统一的物理寄存器中（或旁路网络中）读取操作数</li><li>Execute: <code>UOP</code>进入功能部件执行其功能</li><li>Memory: <code>Load Address Queue(LAQ)</code>, <code>Store Address Queue(SAQ)</code>, <code>Store Data Queue(SDQ)</code>。<code>Load</code>指令会在计算出地址并放入<code>LAQ</code>时就访问内存，但<code>Store</code>指令要到<code>Commit</code>阶段才会访问内存</li><li>Writeback: <code>ALU</code>和访存指令结果写回物理寄存器堆</li><li>Commit: 当<code>ROB</code>首指令空闲时进行指令提交，对于存储指令(Store)，此时<code>ROB</code>向<code>SAQ/SDQ</code>发出信号，使其进行内存写入</li></ol><h2 id="整体架构图"><a class="markdownIt-Anchor" href="#整体架构图"></a> 整体架构图</h2><p><img src="/images/boom-pipeline-detailed.webp" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;riscv-boom-pipeline&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#riscv-boom-pipeline&quot;&gt;&lt;/a&gt; RISCV-BOOM Pipeline&lt;/h1&gt;
&lt;h2 id=&quot;流水段划分&quot;&gt;&lt;a class=</summary>
      
    
    
    
    <category term="Computer Architecture" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/"/>
    
    <category term="RISCV-BOOM" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/RISCV-BOOM/"/>
    
    
    <category term="Code Reading" scheme="https://taosicheng2001.github.io/tags/Code-Reading/"/>
    
  </entry>
  
  <entry>
    <title>Cache Coherence Instances</title>
    <link href="https://taosicheng2001.github.io/2024/04/02/Cache-Coherence-Instances/"/>
    <id>https://taosicheng2001.github.io/2024/04/02/Cache-Coherence-Instances/</id>
    <published>2024-04-02T03:18:59.000Z</published>
    <updated>2024-05-05T15:00:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sgi-origin"><a class="markdownIt-Anchor" href="#sgi-origin"></a> SGI ORIGIN</h1><p><img src="/images/SGIOrigin.png" alt="" /></p><p>专为大规模高可扩展系统设计</p><p><strong>特点</strong></p><ul><li>动态选择<code>coaese bit vector</code>或<code>limited pointer</code>来表示目录中的<code>share list</code>，以节省空间</li><li>由于不要求互联网络的强有序性，需要考虑额外的一致性消息竞争问题</li><li>使用不表示占用属性的<code>E</code>状态，允许<code>E</code>状态和<code>S</code>状态的静默换出，这将导致<code>GetS</code>的回复过程变得更复杂</li><li>使用<code>Upgrade</code>一致性请求将<code>S</code>状态升格为<code>E</code>状态，不需要请求数据</li><li>将三种网络（<code>request</code>, <code>forwarded request</code>和<code>response</code>）减少为两种（<code>request</code> 和 <code>response</code>）。由此导致的死锁情况通过额外的<code>Backoff</code>消息来处理</li></ul><h1 id="coherent-hypertransport"><a class="markdownIt-Anchor" href="#coherent-hypertransport"></a> Coherent HyperTransport</h1><p><img src="/images/CoherenceHT.png" alt="" /></p><p>为中小规模扩展系统设计,实际上目录到核心使用广播传递（forwarded）消息，核心到目录使用点对点链路</p><p><strong>特点</strong></p><ul><li>采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>i</mi><msub><mi>r</mi><mn>0</mn></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">Dir_0B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>目录协议，是一种<code>null directory cache</code>设计，目录不储存任何缓存块，所有发送到目录的请求都会Miss，然后通过广播被目录前递到所有缓存块</li><li>不需要全序的一致性请求，对于互联网络而言具有更大的扩展性</li><li>事实上比广播一致性协议更消耗带宽，因为所有<code>forward</code>操作都将产生<code>response</code></li></ul><h1 id="hypertransport-assist"><a class="markdownIt-Anchor" href="#hypertransport-assist"></a> Hypertransport Assist</h1><p><strong>特点</strong></p><ul><li>采用<code>inclusive directory cache</code>设计，只缓存归属于自己片内的，在上层缓存中有效的块，没有DRAM目录</li><li>在目录缓存中的Miss意味着当前请求的块不存在于该片的任何一个地方</li><li>当目录缓存满还需要加入新项时，利用<code>Recall</code>操作进行换出</li><li>用更少的标志位来表示<code>share list</code>，只区分没有<code>sharer</code>，一个<code>sharer</code>，两个及以上<code>sharer</code>这三种状态</li><li>要求目录项数量是缓存块的两倍，但不采用显式<code>PutS</code>请求</li><li>目录缓存共享LLC</li></ul><h1 id="intel-qpi"><a class="markdownIt-Anchor" href="#intel-qpi"></a> Intel QPI</h1><p><strong>特点</strong></p><ul><li>支持<code>MESIF</code>五种状态，<code>F</code>状态是未被修改的只读状态。与<code>S</code>状态不一样的是，<code>F</code>状态可以向一致性请求返回数据;与<code>O</code>状态不一样的是，<code>F</code>状态是未修改的，所以可以进行静默替换</li><li><code>F</code>状态使得核心可以<strong>直接</strong>从缓存中获取只读数据，而不是从目录的回复中获取</li><li>提供两种协议模式，<code>home snoop</code>和<code>source snoop</code>：<ul><li><code>Home Snoop</code>模式用于高可扩展情形。此时目录作为协议中的串行化节点，解决消息竞争问题</li><li><code>Source Snoop</code>模式用于低时延情形。此时利用广播向所有节点请求块，代价是降低其可扩展性。虽然相较于<code>Home Snoop</code>占用了更多的带宽，但其一致性事务的平均处理时间大大降低了</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sgi-origin&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sgi-origin&quot;&gt;&lt;/a&gt; SGI ORIGIN&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/SGIOrigin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Computer Architecture" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/"/>
    
    <category term="Cache Coherence" scheme="https://taosicheng2001.github.io/categories/Computer-Architecture/Cache-Coherence/"/>
    
    
    <category term="Direcotry Protocol" scheme="https://taosicheng2001.github.io/tags/Direcotry-Protocol/"/>
    
  </entry>
  
</feed>
